<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .links {
        stroke-width: 0.5;
        opacity: 1;
        stroke: black;
    }

    .nodes {
        stroke-width: 1;
        opacity: 1;
        stroke: green;
        fill: green;

    }

    .cell-obst {
        stroke-width: 0.1;
        opacity: 0.5;
        stroke: black;
        fill: red;
    }

    .cell-free {
        stroke-width: 0.1;
        opacity: 1;
        stroke: black;
        fill: white;
    }

    .cell-door {
        stroke-width: 0.1;
        opacity: 0.5;
        stroke: black;
        fill: blue;
    }
</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
    var gScale = -1;
    var gTransl;
    var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0],
            x = w.innerWidth || e.clientWidth || g.clientWidth,
            y = w.innerHeight || e.clientHeight || g.clientHeight;

    var width = x - 20;
    var height = y - 20;
    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);
    var g = svg.append("g");
    var g2 = svg.append("g");

    d3.json("grid.json", function (error, grid) {
        var projection = d3.geo.projection(function (x, y) {
            return [x, y];
        }).precision(0).scale(1).translate([0, 0]);
        var geometries = Array.from(grid.map(function (d) {
            var kind = d.kind;
            var x = d.x;
            var y = d.y;
            var width = d.width;
            var c0 = [x, y];
            var c1 = [x, y + width];
            var c2 = [x + width, y + width];
            var c3 = [x + width, y];
            var st;
            if (kind == 0) {
                st = "cell-free";
            } else if (kind == -2) {
                st = "cell-door";
            } else {
                st = "cell-obst";
            }

            var ret = {type: "Polygon", coordinates: [[c0, c1, c2, c3, c0]], geostyle: st};

            return ret;
        }));
        var features = geometries.map(function (geom) {
            return {type: "Feature", geometry: geom}
        });
        var featureCollection = {type: "FeatureCollection", features: features};
        var path = d3.geo.path().projection(projection);
        if (gScale == -1) {

            var bounds = path.bounds(featureCollection),
                    scale = 1.05 / Math.max((bounds[1][0] - bounds[0][0]) / width,
                                    (bounds[1][1] - bounds[0][1]) / height),
                    transl = [(width - scale * (bounds[1][0] + bounds[0][0])) / 2,
                        (height - scale * (bounds[1][1] + bounds[0][1])) / 2];
            gScale = scale;
            gTransl = transl;
        } else {
            scale = gScale;
            transl = gTransl;
        }
        projection.scale(scale).translate(transl);
        path.projection(projection);//.pointRadius(.1);
        g.selectAll("path")
                .data(features)
                .enter().append("path")
                .attr("d", path)
                .attr("class", function (d) {
                    return d.geometry.geostyle;

                });


    });

    //    d3.xml("network.xml", "application/xml", function (error, xml) {
    //        var projection = d3.geo.projection(function (x, y) {
    //            return [x, y];
    //        }).precision(0).scale(1).translate([0, 0]);
    //
    //        var dict = {};
    //        var geometries = Array.from(xml.documentElement.getElementsByTagName("node")).map(function (d) {
    //            var x = d.attributes.getNamedItem("x").nodeValue;
    //            var y = d.attributes.getNamedItem("y").nodeValue;
    //            dict[d.attributes.getNamedItem("id").nodeValue] = [x, y];
    //            return {type: "Point", coordinates: [x, y], geostyle: "nodes"}
    //        });
    //        geometries = geometries.concat(Array.from(xml.documentElement.getElementsByTagName("link")).map(function (d) {
    //            var from = d.attributes.getNamedItem("from").nodeValue;
    //            var to = d.attributes.getNamedItem("to").nodeValue;
    //            var fromC = dict[from];
    //            var toC = dict[to];
    //
    //            return {type: "LineString", coordinates: [fromC, toC], geostyle: "links"};
    //        }));
    //        var features = geometries.map(function (geom) {
    //            return {type: "Feature", geometry: geom}
    //        });
    //        var featureCollection = {type: "FeatureCollection", features: features};
    //        var path = d3.geo.path().projection(projection);
    //
    //        if (gScale == -1) {
    //            var bounds = path.bounds(featureCollection),
    //                    scale = 1.05 / Math.max((bounds[1][0] - bounds[0][0]) / width,
    //                                    (bounds[1][1] - bounds[0][1]) / height),
    //                    transl = [(width - scale * (bounds[1][0] + bounds[0][0])) / 2,
    //                        (height - scale * (bounds[1][1] + bounds[0][1])) / 2];
    //
    //            gScale = scale;
    //            gTransl = transl;
    //        } else {
    //            scale = gScale;
    //            transl = gTransl;
    //        }
    //        projection.scale(scale).translate(transl);
    //        path.projection(projection);//.pointRadius(.1);
    //        g2.selectAll("path")
    //                .data(features)
    //                .enter().append("path")
    //                .attr("d", path)
    //                .attr("class", function (d) {
    //                    return d.geometry.geostyle;
    //                });
    //    });


    // zoom and pan
    var zoom = d3.behavior.zoom()
            .on("zoom", function () {
                g.attr("transform", "translate(" + d3.event.translate.join(",") + ")scale(" + d3.event.scale + ")");
//                g2.attr("transform", "translate(" + d3.event.translate.join(",") + ")scale(" + d3.event.scale + ")");
            });
    svg.call(zoom)
</script>

